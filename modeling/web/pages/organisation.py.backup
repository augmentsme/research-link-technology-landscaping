"""
Organisation Insights Page
Focus on grant, keyword, and category trends for a single organisation.
"""
import streamlit as st
import pandas as pd
import sys
from pathlib import Path
from typing import List, Optional, Sequence, Tuple

# Ensure shared utilities are importable
web_dir = str(Path(__file__).parent.parent)
if web_dir not in sys.path:
    sys.path.insert(0, web_dir)

from shared_utils import load_data  # noqa: E402


st.set_page_config(
    page_title="Organisation Insights",
    layout="wide",
    initial_sidebar_state="expanded",
)

METRIC_OPTIONS = {
    "funding": "Funding amount",
    "count": "Grant count",
}


def _select_year_range(grants_df: pd.DataFrame) -> Tuple[Optional[int], Optional[int]]:
    if 'start_year' not in grants_df.columns:
        return None, None
    valid_years = grants_df['start_year'].dropna().astype(int)
    if valid_years.empty:
        return None, None
    min_year = int(valid_years.min())
    max_year = int(valid_years.max())
    if min_year == max_year:
        st.sidebar.caption(f"Year range fixed at {min_year}")
        return min_year, max_year
    default_start = min(max(2000, min_year), max_year)
    selected_min, selected_max = st.sidebar.slider(
        "Year range",
        min_value=min_year,
        max_value=max_year,
        value=(default_start, max_year),
        help="Limit grants to those active within this period.",
    )
    return selected_min, selected_max


def _format_org_label(org_id: str) -> str:
    return org_id.replace("_", " ")


def _filter_grants(
    grants_df: pd.DataFrame,
    organisation_ids: Sequence[str],
    label: str,
    year_min: Optional[int],
    year_max: Optional[int],
    use_active_period: bool,
) -> pd.DataFrame:
    if not organisation_ids or 'organisation_ids' not in grants_df.columns:
        return pd.DataFrame()

    exploded = grants_df.explode('organisation_ids')
    filtered = exploded[exploded['organisation_ids'].isin(organisation_ids)].copy()
    if filtered.empty:
        return pd.DataFrame()

    if year_min is None and year_max is None:
        return filtered.drop_duplicates(subset='id').assign(organisation=label)

    if use_active_period:
        mask = filtered.apply(
            lambda row: bool(
                compute_active_years(
                    row.get('start_year'),
                    row.get('end_year'),
                    use_active_period=True,
                    min_year=year_min,
                    max_year=year_max,
                )
            ),
            axis=1,
        )
    filtered = filtered[mask]
    return filtered.drop_duplicates(subset='id').assign(organisation=label)

    if year_min is not None:
        filtered = filtered[filtered['start_year'] >= year_min]
    if year_max is not None:
        filtered = filtered[filtered['start_year'] <= year_max]
    return filtered.drop_duplicates(subset='id').assign(organisation=label)


def _prepare_keyword_data(keywords_df: pd.DataFrame, grant_ids: set[str]) -> pd.DataFrame:
    if keywords_df is None or keywords_df.empty:
        return pd.DataFrame()
    keywords = keywords_df.copy()
    keywords['grants'] = keywords['grants'].apply(
        lambda ids: [g for g in ids if g in grant_ids] if isinstance(ids, list) else []
    )
    keywords = keywords[keywords['grants'].apply(len) > 0]
    return keywords


def _prepare_category_data(categories_df: pd.DataFrame, keyword_names: set[str]) -> pd.DataFrame:
    if categories_df is None or categories_df.empty:
        return pd.DataFrame()
    categories = categories_df.copy()
    if 'keywords' not in categories.columns:
        return pd.DataFrame()
    categories = categories[categories['keywords'].apply(
        lambda items: any(keyword in keyword_names for keyword in items) if isinstance(items, list) else False
    )]
    return categories


def _summarise_grants(grants_df: pd.DataFrame) -> Tuple[int, float, Tuple[int, int]]:
    if grants_df.empty:
        return 0, 0.0, (0, 0)
    total = len(grants_df)
    funding = float(grants_df['funding_amount'].fillna(0).sum()) if 'funding_amount' in grants_df.columns else 0.0
    if 'start_year' in grants_df.columns and not grants_df['start_year'].dropna().empty:
        years = grants_df['start_year'].dropna().astype(int)
        return total, funding, (int(years.min()), int(years.max()))
    return total, funding, (0, 0)


def _format_currency(value: float) -> str:
    if value <= 0:
        return "N/A"
    return f"${value:,.0f}"


def main() -> None:
    keywords_df, grants_df, categories_df = load_data()
    if grants_df is None or grants_df.empty:
        st.error("Grants data unavailable.")
        return

    if 'organisation_ids' not in grants_df.columns:
        st.error("Grants data missing organisation identifiers.")
        return

    exploded = grants_df.explode('organisation_ids').dropna(subset=['organisation_ids'])
    organisation_counts = (
        exploded.groupby('organisation_ids')['id']
        .nunique()
        .sort_values(ascending=False)
    )
    if organisation_counts.empty:
        st.error("No funded organisations found in the dataset.")
        return
    organisation_options = organisation_counts.index.tolist()

    st.title("Organisation Insights")
    st.caption("Explore grants, keywords, and categories associated with a funded organisation.")

    with st.sidebar:
        st.header("Organisation Focus")
        search_phrase = st.text_input(
            "Match funded organisations containing",
            value="",
            help="Type part of the organisation name to group every matching entry (case insensitive).",
        ).strip()

        selected_orgs: List[str] = []
        selection_label: str = ""

        if search_phrase:
            matched_orgs = [org for org in organisation_options if search_phrase.lower() in org.lower()]
            if matched_orgs:
                st.caption(f"Found {len(matched_orgs)} organisation entries containing “{search_phrase}”.")
                with st.expander("Matched identifiers", expanded=False):
                    for org in matched_orgs:
                        st.write(_format_org_label(org))
                use_all_matches = st.checkbox(
                    "Use every matching entry",
                    value=True,
                    help="When enabled, all organisations containing the phrase are combined into one selection.",
                )
                if use_all_matches:
                    selected_orgs = matched_orgs
                else:
                    selected_orgs = st.multiselect(
                        "Matching entries",
                        options=matched_orgs,
                        default=matched_orgs,
                        format_func=_format_org_label,
                    )
                if selected_orgs:
                    selection_label = f"{search_phrase} ({len(selected_orgs)} entries)"
            else:
                st.info("No organisation identifiers match that phrase. Using the full list instead.")

        if not selected_orgs:
            selected_org = st.selectbox(
                "Funded organisation",
                organisation_options,
                format_func=_format_org_label,
            )
            selected_orgs = [selected_org]
            selection_label = _format_org_label(selected_org)

        use_active_period = st.checkbox(
            "Treat grants as active through their end year",
            value=True,
            help="Counts each grant in every year between start and end dates.",
        )
        year_min, year_max = _select_year_range(grants_df)
        top_keywords = st.slider("Top keywords", min_value=5, max_value=20, value=10)
        top_categories = st.slider("Top categories", min_value=5, max_value=15, value=8)
        metric_keys = list(METRIC_OPTIONS.keys())
        metric_choice = st.selectbox(
            "Y-axis metric",
            metric_keys,
            index=0,
            format_func=lambda key: METRIC_OPTIONS[key],
            help="Determines both the displayed values and how entities are ranked."
        )
        smooth_trends = st.checkbox(
            "Smooth trend lines",
            value=True,
            help="Apply a rolling average to yearly counts."
        )
        if smooth_trends:
            smoothing_window = st.slider(
                "Rolling window (years)",
                min_value=2,
                max_value=10,
                value=5,
                step=1,
                help="Number of years included in the rolling average."
            )
        else:
            smoothing_window = 1
    window_size = smoothing_window if smooth_trends else 1
    value_column = 'total_funding' if metric_choice == 'funding' else 'grant_count'
    ranking_column = value_column
    y_axis_label = METRIC_OPTIONS[metric_choice]

    filtered_grants = _filter_grants(grants_df, selected_orgs, selection_label, year_min, year_max, use_active_period)
    if filtered_grants.empty:
        st.warning("No grants match the current filters. Try adjusting the year range or active-period setting.")
        return

    grant_ids = set(filtered_grants['id'])
    keyword_df = _prepare_keyword_data(keywords_df, grant_ids)
    keyword_names = set(keyword_df['name']) if 'name' in keyword_df.columns else set()
    category_df = _prepare_category_data(categories_df, keyword_names)

    total_grants, total_funding, (range_start, range_end) = _summarise_grants(filtered_grants)
    unique_keywords = len(keyword_df) if not keyword_df.empty else 0
    unique_categories = len(category_df) if not category_df.empty else 0

    stat_cols = st.columns(4)
    stat_cols[0].metric("Organisation", selection_label)
    stat_cols[1].metric("Grants", f"{total_grants:,}")
    stat_cols[2].metric("Funding", _format_currency(total_funding))
    if range_start and range_end:
        stat_cols[3].metric("Active Years", f"{range_start}-{range_end}")
    else:
        stat_cols[3].metric("Active Years", "N/A")

    secondary_cols = st.columns(2)
    secondary_cols[0].metric("Keywords", f"{unique_keywords:,}")
    secondary_cols[1].metric("Categories", f"{unique_categories:,}")

    st.markdown("---")
    st.subheader("Grant Trends")
    grants_trend = TrendsDataPreparation.from_grants_by_attribute(
        filtered_grants,
        'organisation',
        use_active_period=use_active_period,
        year_min=year_min,
        year_max=year_max,
    )
    if grants_trend.empty:
        st.info("No grant trend data available.")
    else:
        grant_config = TrendsConfig(
            entity_col='organisation',
            time_col='year',
            value_col=value_column,
            ranking_col=ranking_column,
            aggregation='sum',
            use_cumulative=False,
            chart_type='area',
            max_entities=1,
            title=f"Grant trends for {selection_label}",
            x_label="Year",
            y_label=y_axis_label,
            height=420,
            smooth_trends=smooth_trends,
            smoothing_window=window_size,
        )
        grant_fig = TrendsVisualizer().create_plot(grants_trend, grant_config)
        st.plotly_chart(grant_fig, width=True)

    st.markdown("---")
    st.subheader("Keyword Trends")
    keyword_trend_all = TrendsDataPreparation.from_keyword_grants(
        keyword_df,
        filtered_grants,
        selected_keywords=None,
        use_active_period=use_active_period,
        year_min=year_min,
        year_max=year_max,
    )
    if keyword_trend_all.empty:
        st.info("No keywords linked to this organisation.")
    else:
        keyword_totals = (
            keyword_trend_all.groupby('keyword')[ranking_column]
            .sum()
            .sort_values(ascending=False)
        )
        top_keyword_names = keyword_totals.head(top_keywords).index.tolist()
        if not top_keyword_names:
            st.info("No keyword trend data available for this selection.")
        else:
            keyword_trend = keyword_trend_all[keyword_trend_all['keyword'].isin(top_keyword_names)]
            keyword_config = TrendsConfig(
                entity_col='keyword',
                time_col='year',
                value_col=value_column,
                ranking_col=ranking_column,
                aggregation='sum',
                use_cumulative=False,
                chart_type='line',
                max_entities=len(top_keyword_names),
                title=f"Top keywords in {selection_label} grants",
                x_label="Year",
                y_label=y_axis_label,
                height=420,
                smooth_trends=smooth_trends,
                smoothing_window=window_size,
            )
            keyword_fig = TrendsVisualizer().create_plot(keyword_trend, keyword_config)
            st.plotly_chart(keyword_fig, width=True)

    st.markdown("---")
    st.subheader("Category Trends")
    if category_df.empty:
        st.info("No categories linked to this organisation.")
        return
    category_trend_all = TrendsDataPreparation.from_category_grants(
        category_df,
        filtered_grants,
        selected_categories=None,
        use_active_period=use_active_period,
        year_min=year_min,
        year_max=year_max,
    )
    if category_trend_all.empty:
        st.info("No category trend data available for this selection.")
        return
    category_totals = (
        category_trend_all.groupby('category')[ranking_column]
        .sum()
        .sort_values(ascending=False)
    )
    top_category_names = category_totals.head(top_categories).index.tolist()
    if not top_category_names:
        st.info("No category trend data available for this selection.")
        return
    category_trend = category_trend_all[category_trend_all['category'].isin(top_category_names)]
    category_config = TrendsConfig(
        entity_col='category',
        time_col='year',
        value_col=value_column,
        ranking_col=ranking_column,
        aggregation='sum',
        use_cumulative=False,
        chart_type='line',
        max_entities=len(top_category_names),
        title=f"Category trends for {selection_label}",
        x_label="Year",
        y_label=y_axis_label,
        height=420,
        smooth_trends=smooth_trends,
        smoothing_window=window_size,
    )
    category_fig = TrendsVisualizer().create_plot(category_trend, category_config)
    st.plotly_chart(category_fig, width=True)


if __name__ == "__main__":
    main()
